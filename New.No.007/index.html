<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div>
      브라우저가 어떻게 작동하는지, 즉 html 파일을 받아서 어떻게 화면에
      출력하는지에 대해서 간단하게만 설명
    </div>
    <div>Javascript를 html에서 사용하는 방법, 변수? 자료형</div>
    <div>변수</div>
    <script>
      // script는 html에서 Javascript를 입력하는 태그
      // HTML, CSS, Javascript는 문법이 다 다름
      // 지금까지 했던 HTML, CSS는 구조적으로 많이 함
      // 프로그래밍 적으로는 Javascript
      // 변수란 데이터를 담은 상자
      // ex) 이사를 한다 -> 상자에 뭫 담았는지 이름을 붙인다, -> 상자 안에 맞는 물건 담기 -> 차에 싣기
      // 데이터를 사용 -> 변수를 선언 -> 변수에 데이터를 정의 -> 렘에 담는다.
      // 다른 프로그램에서는 위치를 알 수 있지만(메모리), Javascript에서는 없다.
      // var는 계속 선언이 가능하기에 다른 내용임에도 불구하고 선언한 이름이 같아서 헷갈리는 경우가 생긴다.

      var var1 = 1;
      // var은 변수 선언 시 사용하는 명령어
      // var 명령어를 사용해서 var1을 초기화했다.
      // var는 편하게 계속 맘대로 사용가능
      var1 = 2;
      // var1을 정의했다, 값을 대입했다, 값을 넣었다.
      console.log(var1);
      var var1 = "var2";
      // var1을 다시 초기화했다. 선언하고 정의했다. 이름을 다시 붙이고 값을 다시 넣었다.
      console.log(var1);
      var var1;
      // var1을 다시 선언했다.
      console.log(var1);

      var var1 = "var1";
      // var는 요즘 사용 안함
      // 여러 사람들이 같이 작업할 때 같은 변수를 사용하면서 다른 의미로 사용하게 될 수가 있다.
      // 길동이가 a라는 변수를 선언하고 거기에 1을 정의한 후에 출석 날짜로 사용하고 있다.
      // 둘리가 같은 프로젝트를 진행하면서 a라는 변수를 주고 결석 날짜로 사용해버린다.
      // 같은 파일 내에서 2가지의 의미로 사용된다. a라는 게 정확히 뭘 뜻하는지 알 수 없게 된다.

      let let1 = 1;
      const const1 = 1;
      // let은 선언 후에 재정의가 가능하다. (변수)
      // 선언 후 같은 이름으로 재선언이 불가능하다.
      // const는 선언 후에 재정의가 불가능하다.
      // const는 상수 (변하지 않는 값)

      let let2;
      // -> let2를 선언했다.
      // 앞으로 쓸 것이다 / 상자에 이름을 붙인다.
      let2 = 2;
      // let2를 정의했다. / 상자에 물건을 담는다.
      // * let let2; 재선언 불가능
      let let3 = 3;
      // let3을 초기화했다. / 상자에 이름을 붙이면서 물건을 담는다.
      // const const2; 선언만 하면 데이터가 없기 때문에 빨간줄이 뜬다. (오류가 생김)
      // const1 = 3; -> 재정의가 불가능하기 때문에 개발자 도구의 콘솔창에서 문제가 발생한다.
      console.log("asdf");
      //   이름 그대로 콘솔에 로그를 남긴다 (기록)
      console.log(let1);
      //  'let1에 대한 정보를 가져와 달라'는 의미
      console.log(const1);
      console.log(let2);
      console.log(let3);
      //   어디에 문제가 생겼는지 확인하고자 남기는 log
      //   console.log에서 정의한 값에서 문제가 생기게 되면 개발자도구에서 오류가 표출된다.
      // 자료형
      // string, number, boolean, undefined, null, object, array
      // string 은 텍스트
      // number 는 숫자
      // boolean 은 참거짓, (bool값 썼냐?고 표현)
      // undefined, null 둘다 값이 없는 것
      // object 는 키와 값으로 이루어진 객체다.
      // array 는 배열, 더 깊이 얘기는 나중에
      let string1 = "abcd";
      let string2 = "abcd";
      let string3 = `abcd`;
      //   ` 은 1 옆에 esc 아래에 있는 것이다. > 영어일 때
      //  "", '' 한줄 텍스트
      // `` 템플릿 리터널 이라고 부르며, 여러줄 가능
      // let string4 = `
      // sadlkfjalsdkfjslkfj
      // `
      // let string5 = "
      // asdlkfjlsdkfj
      // "
      let string6 =
        "\
                      sdfasdfdfdsf\
                      ";
      //   \ (다음줄로 무조건 내리겠다는 뜻)
      //  ; 이 없어도 가능하지만, Javascript 이외의 언어에서 협업할 경우 호환 때문에 사용하는 것이 좋음.

      let number1 = 1;
      let number2 = 1.1;
      let number3 = 1 / 3;
      let number4 = "1";
      // number는 말 그대로 숫자
      // 계산식을 정의해도 숫자가 정상적으로 들어간다.
      // ex) number4는 숫자가 아닌 텍스트 (let을 사용하지 않고, number만 할 경우 var로 포함된다.)
      // 보통 let과 const로 많이 사용함

      let boolean1 = true;
      let boolean2 = false;
      let boolean3 = 1;
      let boolean4 = "sldkfj";
      // boolean은 참거짓을 갖는다.
      // boolean3은 참인가? 거짓인가? -> 참이다 (컴퓨터가 1과 0으로 따지기 떄문에 이진법 1 이상은 무조건 참이라고 취급한다.)
      // boolean4는 참인가? 거짓인가? -> 참이다 (값을 갖고 있기 때문에 데이터를 갖고 있기 때문에 데이터가 없을 경우 거짓으로 취급한다.)
      let boolean5 = 0;
      let boolean6 = "0";
      let boolean7 = "";
      // boolean6은 참이다 -> "0" 이라는 값(텍스트)을 가지고 있는 것
      // boolean7 거짓이다 -> "" 텍스트가 비어 있이 때문에 거짓이다. " " (space-bar 빈 공간도 데이터가 있다고 판단)
      let boolean8 = "\uac00";
      let boolean9 = " ";
      let boolean10 = "";
      console.log(boolean8);
      console.log(!!boolean9);
      console.log(!!boolean10);

      let undefined1 = undefined;
      let null1 = null;
      // 위의 코드 차이점이란?
      // undefined 는 초기값, 내가 설정하지 않은 없는 값, 빈 값
      // Javascript만 한 사람은 undefined
      // null은 내가 설정한 빈 값
      // 다른 언어 했던 사람이 null
      // 데이터 전송 시 상대방이 같은 언어를 사용하지 않을 경우 null값을 넣어줘야 할 경우가 있다.

      let obj = {};
      // object는 키와 값으로 이루어진 객체, 중괄호로 정의함
      // const obj = {}; >> const는 재정의가 불가능하기 때문에 오류가 뜸
      // obj = { a: 1, b: 2, c: "3" }; > 객체를 묶어서 정의
      obj.a = 1;
      obj.b = boolean7;
      obj.c = "3";
      // a, b, c 를 키라고 하고 1, 2, "3"을 값이라 한다.
      // 객체를 따로따로 정의 가능함
      // 객체
      // a, b, c 를 키라고 하고 1, 2, "3"을 값이라 한다.
      // { a: 1, b: a, c: "3"} >> a 값이라는 변수를 갖고 온다
      // obj = { a: 1, b: boolean7, c: "3" }; >> boolean7 데이터값을 가져온다.
      obj.a = "홍길동";
      obj.b = "boolean7";
      console.log(obj.a);
      console.log(obj.b);
      console.log(obj.c);
      // 객체와 배열을 데이터 값으로 남기는 것 (키)
      // - 를 사용할 경우 마이너스 계산식으로 받아드린다 (텍스트로 인식 안 함)

      let arr1 = [1, 2, "3", { a: 1, b: 2, c: "3" }, true, [obj.a], obj];
      const arr2 = [];
      // 배열 (array)는 순차적인 데이터이다.

      console.log(arr1);
      console.log(arr1[0]);
      // arr1 [몇번째 있는지] 넣으면 그 몇번째의 값을 가져온다.
      // arr1[0]은 배열의 첫번째 값을 가져온다.
      console.log(arr1[1]);
      // arr1[1]은 배열의 두번째 값을 가져온다.
      console.log(arr1[2]);
      // arr1[2]은 배열의 세번째 값을 가져온다.

      console.log(arr1);

      arr1.push(123);
      arr1.push("abc");
      // push 는 arr1의 순차적인 데이터에 뒤에서 데이터를 추가할 때 사용한다.

      console.log(arr1);
      let pop1 = arr1.pop();
      // pop은 arr1 데이터 목록의 뒤에서 뺀다.
      console.log(arr1);
      console.log(pop1);
      //   arr1의 데이터 목록 중 뒤에서 뺀 내용을 갖는다.
      arr1.unshift("unshift");
      console.log(arr1);
      let shift1 = arr1.shift();
      // shift는 앞에서 뺀다.
      console.log(arr1);
      console.log(shift1);
      //   사용할 경우 정의를 해준 뒤 사용 해줄 것 ex)console.log(arr1) > arr1 이라는 데이터 주체

      console.log(typeof shift1);
      console.log(typeof string1);
      console.log(typeof number1);
      console.log(typeof boolean1);
      console.log(typeof undefined1);
      console.log(typeof null1);
      console.log(typeof obj);
      console.log(typeof obj.a);
      console.log(typeof obj.b);
      console.log(typeof obj.c);
      console.log(typeof arr1);
      console.log(typeof arr1[0]);
      console.log(typeof arr1[2]);
      console.log(typeof arr1[3]);
      // typeof 변수의 자료혈을 어떤 자료형인지 알려 주는 것

      // 변수명, let/const *** 에서 ***이 변수명 (식별자)이다.
      // 변수에 대한 표기법 (식별자 표기법)
      // Kebab Case, 케밥 표기법
      // let kebab-case << CSS에서, Class이름 -> kebab 빼기 case로 인식해서 적용 안됨
      let camelCase;

      // ex) let studentName;
      // 협약하여 사용할 경우 사용
      // Camel Case, 카멜표기법, 낙타, Javascript에서 변수명, 함수명 등등 이름 선언할 때 왠만하면 사용할 것. (예외: React)
      // 대문자로 단어 구분을 한다. 소문자 > name 사용
      // 마우스를 갖다 댔을 경우 any라고 뜰 경우 아무 값이나 대입할 수 있다는 뜻
      let snake_case;
      // Snake Case, 스네이크표기법, 뱀 (서버쪽에서 데이터 주고 받을 경우 많이 사용)
      let PascalCase;
      // const PascalCase; > 내용을 넣어야 하므로 let을 사용하여 강의한 것
      // Pascal Case, 파스칼 표기법, 사용처 : React
      let strHungarianNotation;
      // Hungarian notation, 헝가리안 표기법, 요즘 사용 안함.
      // str은 string의 약자로 헝가리안 표기법에서는 변수명의 제일 앞에 자료형을 적어준다.
      let studentName;
      let obj1 = {
        "test code": 1,
        test_code: 2,
      };
      //  속성안에서는 띄어쓰기가 가능
      console.log(obj1["test code"]);
    </script>
  </body>
</html>
